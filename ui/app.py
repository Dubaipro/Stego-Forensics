import sys
from functools import wraps

import cv2
from flask import Flask, render_template, request, redirect, url_for, flash, session, abort, send_from_directory, \
    jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from validate_email_address import validate_email
from werkzeug.security import generate_password_hash, check_password_hash
from flask_migrate import Migrate
import hashlib
import os
import re
from datetime import datetime, timedelta
import random
from flask_mail import Mail, Message
from werkzeug.utils import secure_filename
import uuid
import shutil
import numpy as np
from itsdangerous import URLSafeTimedSerializer
from sqlalchemy import func
from flask import make_response
from jinja2 import Template
from fpdf import FPDF
from itsdangerous import URLSafeTimedSerializer


from flask import jsonify
from sqlalchemy import func
from collections import defaultdict

from flask import make_response
from xhtml2pdf import pisa
import io





# Custom modules
from embedding.embed import embed_data
from embedding.extract import extract_data
from crypto.signature import sign_message, verify_signature
from Crypto.PublicKey import RSA



# Utility Functions
def generate_verification_code():
    return str(random.randint(100000, 999999))

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
# Example setup for metadata_versions
# Assuming metadata_versions is a list of lines or data blocks that are being processed
metadata_versions = [
    "Block 1 data",
    "Block 2 data",
    "Block 3 data"
]


# Function to parse a metadata block
def parse_metadata_block(block):
    # Replace this placeholder logic with your actual parsing implementation
    return f"Parsed {block}"


# Parsing the metadata into a new list
parsed_versions = [parse_metadata_block(block) for block in metadata_versions]

# Output the parsed versions to verify the results
print(parsed_versions)

pdf = FPDF()
pdf.add_page()
pdf.set_font("Arial", size=12)
pdf.cell(200, 10, txt="Hello, this is a PDF file generated by fpdf!", ln=True)
pdf.output("simple_example.pdf")

def send_verification_email(email, code):
    msg = Message('üîê Your Verification Code', sender=app.config['MAIL_USERNAME'], recipients=[email])
    msg.body = f"Your verification code is: {code}"
    mail.send(msg)
def some_function():
    from app import db
    # Use 'db' here

def generate_2fa_code():
    return str(random.randint(100000, 999999))

def send_2fa_email(email, code):
    msg = Message("üîê Your 2FA Code",
                  sender=app.config['MAIL_USERNAME'],
                  recipients=[email])
    msg.body = f"Your 2FA code is: {code}\n\nThis code is valid for 1 minutes."
    mail.send(msg)
def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role.lower() != 'admin':
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

def verify_image(image):
    image_path = os.path.join('static', 'upload', image.filename)
    with open(image_path, 'rb') as file:
        file_data = file.read()
        recalculated_signature = hashlib.sha256(file_data).hexdigest()
    return recalculated_signature == image.signature

def send_authority_alert(record):
    admins = User.query.filter_by(role='admin').all()
    if not admins:
        return

    msg = Message(
        subject="üö® Tampering Alert - StegoForensics",
        sender=app.config['MAIL_USERNAME'],
        recipients=[admin.email for admin in admins],
        body=f"""
ALERT: Tampering has been detected in an image.

Case ID: {record.case_id}
Investigator: {record.investigator_name}
Timestamp: {record.timestamp}
Filename: {record.filename}

‚ö†Ô∏è The image failed authenticity verification.
Please investigate this case immediately.
        """
    )
    mail.send(msg)


def extract_data_versions(image_path):
    full_data = extract_data(image_path)
    versions = full_data.strip().split("Metadata:")
    versions = ["Metadata:" + v.strip() for v in versions if v.strip()]
    return versions

    msg.body = f"""
ALERT: A tampering has been detected!

Case ID: {record.case_id}
Investigator: {record.investigator_name}
Timestamp: {record.timestamp}
Filename: {record.filename}

The tampering was detected during a verification attempt.
Please take immediate action.
"""
    mail.send(msg)

# Configurations and Constants
ALLOWED_EXTENSIONS = {'.png', '.jpg', '.jpeg', '.tif', '.tiff'}

def is_allowed_file(filename):
    return os.path.splitext(filename.lower())[1] in ALLOWED_EXTENSIONS

# Use environment variable or fallback to a default upload path
UPLOAD_FOLDER = os.getenv('UPLOAD_FOLDER', os.path.join(os.getcwd(), 'uploads'))
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# Paths and Keys
basedir = os.path.abspath(os.path.dirname(__file__))
key_dir = os.path.join(basedir, 'keys')
os.makedirs(key_dir, exist_ok=True)
private_key_path = os.path.join(key_dir, "private.pem")
public_key_path = os.path.join(key_dir, "public.pem")

if not os.path.exists(private_key_path) or not os.path.exists(public_key_path):
    key = RSA.generate(2048)
    with open(private_key_path, "wb") as f:
        f.write(key.export_key())
    with open(public_key_path, "wb") as f:
        f.write(key.publickey().export_key())

# App Setup
app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'your_secret_key_here')
# Database configuration via environment variable (e.g., DATABASE_URL)
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'postgresql://postgres:202120020@localhost:5432/forensics')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SESSION_PERMANENT'] = False
app.permanent_session_lifetime = timedelta(minutes=120)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ALLOWED_EXTENSIONS'] = ALLOWED_EXTENSIONS

# Flask-Mail config (set these in your environment)
app.config['MAIL_SERVER'] = os.getenv('MAIL_SERVER', 'smtp.gmail.com')
app.config['MAIL_PORT'] = int(os.getenv('MAIL_PORT', 587))
app.config['MAIL_USE_TLS'] = os.getenv('MAIL_USE_TLS', 'True') == 'True'
app.config['MAIL_USERNAME'] = os.getenv('MAIL_USERNAME', 'stegoforensics@gmail.com')
app.config['MAIL_PASSWORD'] = os.getenv('MAIL_PASSWORD', 'cnktiwvmhmtrwppd')

mail = Mail(app)

# DB Init
db = SQLAlchemy(app)
migrate = Migrate(app, db)

# Login Init
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

SERVER_SESSION_ID = str(uuid.uuid4())


# Models
class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(150))
    role = db.Column(db.String(50), default='Investigator')
    is_admin = db.Column(db.Boolean, default=False)
    is_verified = db.Column(db.Boolean, default=False)
    pending_approval = db.Column(db.Boolean, default=True)  # ‚úÖ Default False until admin approval
    verification_code = db.Column(db.String(6), nullable=True)
    two_factor_code = db.Column(db.String(6), nullable=True)
    code_sent_at = db.Column(db.DateTime, nullable=True)




class ForensicRecord(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(200), nullable=False)
    metadata_content = db.Column(db.Text, nullable=False)
    signature = db.Column(db.Text, nullable=False)
    verification = db.Column(db.Boolean, nullable=False)
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    user = db.relationship('User', backref=db.backref('records', lazy=True))
    case_id = db.Column(db.String(255), unique=True, nullable=False)
    investigator_name = db.Column(db.String(150))
    chain_of_custody = db.Column(db.Text)
    notes = db.Column(db.Text)




class ForensicImage(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(255), nullable=False)
    file_metadata = db.Column(db.Text, nullable=False)
    signature = db.Column(db.String(512), nullable=False)
    is_verified = db.Column(db.Boolean, default=False)

class TamperLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    record_id = db.Column(db.Integer, db.ForeignKey('forensic_record.id'), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    discrepancy_details = db.Column(db.Text, nullable=False)
    notified = db.Column(db.Boolean, default=False)

    record = db.relationship('ForensicRecord', backref=db.backref('tamper_logs', lazy=True))

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id))

@app.before_request
def clear_session_on_restart():
    if not request.endpoint or request.endpoint == 'static':
        return

    # If server restarted, the token won't match
    if session.get('server_id') != SERVER_SESSION_ID:
        logout_user()
        session.clear()
        session['server_id'] = SERVER_SESSION_ID  # set new token after logout


@app.route('/')
def root_home():
    if current_user.is_authenticated:
        return render_template('home.html', username=current_user.username)
    return render_template('index.html')  # public landing page
@app.route('/login/<role>', methods=['GET', 'POST'])
def role_login(role):
    valid_roles = ['admin', 'investigator', 'legal']
    if role not in valid_roles:
        abort(403)

    if request.method == 'POST':
        identifier = request.form.get('identifier', '').strip()
        password = request.form.get('password')

        user = User.query.filter((User.username == identifier) | (User.email == identifier)).first()

        if user and check_password_hash(user.password, password):
            if not user.is_verified:
                flash("‚ö†Ô∏è Please verify your email before logging in.", "warning")
                session['email'] = user.email
                return redirect(url_for('verify_email'))
            if user.pending_approval:
                flash("‚è≥ Your account is awaiting admin approval.", "warning")
                return redirect(url_for('role_login', role=role))

            if user.role != role:
                flash(f"üö´ You are not authorized as a {role.capitalize()}.", 'error')
                return redirect(url_for('role_login', role=role))

            login_user(user)
            session['server_id'] = SERVER_SESSION_ID

            # ‚úÖ Generate and send 2FA code
            code = generate_2fa_code()
            user.two_factor_code = code
            user.code_sent_at = datetime.utcnow()
            db.session.commit()

            send_2fa_email(user.email, code)
            flash("üì® 2FA code sent to your email. Please verify to continue.", "info")
            return redirect(url_for('verify_2fa'))

        flash("‚ùå Invalid credentials.", "error")

    return render_template('role_login.html', role=role)

@app.route('/home')
@login_required
def home():
    return render_template('home.html', username=current_user.username)


@app.route('/admin/analytics')
@login_required
@admin_required
def admin_analytics():
    # Example logic to fetch necessary data
    total_users = User.query.count()  # Count total users
    total_uploads = ForensicRecord.query.count()  # Count total forensic uploads

    # Render the admin_analytics.html page with the required data
    return render_template('admin_analytics.html', total_users=total_users, total_uploads=total_uploads)

@app.route('/record/delete/<int:record_id>', methods=['POST'])
@login_required
@admin_required
def delete_forensic_record(record_id):
    record = ForensicRecord.query.get_or_404(record_id)
    db.session.delete(record)
    db.session.commit()
    flash("üóëÔ∏è Record deleted successfully.", "success")
    return redirect(url_for('dashboard'))

@app.route('/admin/analytics/verification_trends')
@login_required
@admin_required
def verification_trends():
    from collections import defaultdict

    trend_data = defaultdict(lambda: {"authentic": 0, "tampered": 0})
    records = ForensicRecord.query.all()

    for record in records:
        week_label = record.timestamp.strftime('%Y-%m-%d')
        was_ever_tampered = TamperLog.query.filter_by(record_id=record.id).first() is not None

        if was_ever_tampered:
            trend_data[week_label]["tampered"] += 1
        else:
            trend_data[week_label]["authentic"] += 1

    # üî• Filter out dates that have zero activity
    filtered_dates = [date for date in trend_data if trend_data[date]["authentic"] > 0 or trend_data[date]["tampered"] > 0]
    sorted_dates = sorted(filtered_dates)

    response = {
        "weeks": sorted_dates,
        "authentic": [trend_data[date]["authentic"] for date in sorted_dates],
        "tampered": [trend_data[date]["tampered"] for date in sorted_dates]
    }

    return jsonify(response)




@app.route('/admin/approve_user/<token>')
def approve_user(token):
    s = URLSafeTimedSerializer(app.config['SECRET_KEY'])
    try:
        data = s.loads(token, max_age=3600)
        email, action = data.split('|')
        user = User.query.filter_by(email=email).first()
        if user and action == 'approve':
            user.pending_approval = False
            user.is_verified = True
            db.session.commit()
            flash(f"‚úÖ User '{user.username}' approved successfully.", "success")
    except Exception:
        flash("‚ùå Invalid or expired approval token.", "error")
    return redirect(url_for('dashboard'))


@app.route('/admin/reject_user/<token>')
def reject_user(token):
    s = URLSafeTimedSerializer(app.config['SECRET_KEY'])
    try:
        data = s.loads(token, max_age=3600)
        email, action = data.split('|')
        user = User.query.filter_by(email=email).first()
        if user and action == 'reject':
            db.session.delete(user)
            db.session.commit()
            flash(f"‚ùå User '{user.username}' was rejected and removed.", "info")
    except:
        flash("‚ùå Invalid or expired rejection token.", "error")
    return redirect(url_for('dashboard'))



@app.errorhandler(403)
def forbidden(e):
    return render_template("403.html"), 403
@app.route('/dashboard')
@login_required
@admin_required
def dashboard():
    if current_user.role != 'admin':
        flash("Access denied", "error")
        return redirect(url_for('home'))

    # Pagination
    page = request.args.get('page', 1, type=int)
    per_page = 10
    paginated_records = ForensicRecord.query.order_by(ForensicRecord.timestamp.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    records = paginated_records.items

    authentic_count = 0
    tampered_count = 0
    forensic_cases = []
    uploaded_images = []

    for record in records:
        image_path = os.path.join('static', 'uploads', record.filename)
        is_valid = False
        extracted = "Missing"

        try:
            if os.path.exists(image_path):
                extracted = extract_data(image_path)
                is_valid = verify_signature(public_key_path, extracted, bytes.fromhex(record.signature))

                # Only update DB status if changed
                if record.verification != is_valid:
                    record.verification = is_valid
                    db.session.commit()

                if not is_valid:
                    tampered_count += 1
                    if not TamperLog.query.filter_by(record_id=record.id).first():
                        tamper = TamperLog(
                            record_id=record.id,
                            discrepancy_details=f"‚ö†Ô∏è Signature mismatch for image '{record.filename}' during dashboard check.",
                            notified=False,
                            timestamp=datetime.utcnow()
                        )
                        db.session.add(tamper)
                        db.session.commit()
                else:
                    authentic_count += 1
            else:
                tampered_count += 1
                is_valid = False
                extracted = "Missing"

        except Exception as e:
            tampered_count += 1
            is_valid = False
            extracted = f"Error: {str(e)}"
            if not TamperLog.query.filter_by(record_id=record.id).first():
                tamper = TamperLog(
                    record_id=record.id,
                    discrepancy_details=f"‚ùå Error verifying: {str(e)}",
                    notified=False,
                    timestamp=datetime.utcnow()
                )
                db.session.add(tamper)
                db.session.commit()

        # Check if tamper log exists
        tamper_log_exists = TamperLog.query.filter_by(record_id=record.id).first() is not None

        forensic_cases.append({
            'id': record.id,
            'title': record.filename,
            'status': 'Tampered' if tamper_log_exists else ('Authentic' if is_valid else 'Tampered'),
            'created_date': record.timestamp.strftime('%Y-%m-%d')
        })

        uploaded_images.append({
            'id': record.id,
            'file_path': record.filename,
            'verification_status': 'Tampered' if tamper_log_exists else ('Authentic' if is_valid else 'Tampered')
        })

    total_cases = authentic_count + tampered_count
    authentic_percent = round((authentic_count / total_cases) * 100) if total_cases else 0
    tampered_percent = round((tampered_count / total_cases) * 100) if total_cases else 0

    return render_template('dashboard.html',
                           total_records=paginated_records.total,
                           forensic_cases=forensic_cases,
                           uploaded_images=uploaded_images,
                           verification_status={
                               'authentic': authentic_count,
                               'tampered': tampered_count
                           },
                           pagination=paginated_records,
                           users=User.query.all(),
                           total_users=User.query.count(),
                           total_uploads=ForensicRecord.query.count(),
                           total_investigators=User.query.filter_by(role='investigator').count(),
                           total_legals=User.query.filter_by(role='legal').count(),
                           authentic_percent=authentic_percent,
                           tampered_percent=tampered_percent)


@app.route('/admin/edit_user/<int:user_id>', methods=['GET'])
@login_required
@admin_required
def edit_user(user_id):
    user = User.query.get_or_404(user_id)
    return render_template('edit_user.html', user=user)


@app.route('/edit_metadata/<int:record_id>', methods=['GET', 'POST'])
@login_required
def edit_metadata(record_id):
    record = ForensicRecord.query.get_or_404(record_id)

    # üõë Prevent editing if the image is marked as tampered
    if not record.verification:
        flash("üö´ You cannot edit metadata for a tampered image. Please re-verify it first.", "error")
        return redirect(url_for('view_metadata', record_id=record.id))

    if request.method == 'POST':
        new_investigator = request.form.get('investigator_name')
        new_chain = request.form.get('chain_of_custody')
        new_notes = request.form.get('notes')

        new_metadata = f"""Case ID: {record.case_id}
Investigator: {new_investigator}
Timestamp: {record.timestamp}
Chain of Custody: {new_chain}
Notes: {new_notes}"""

        image_path = os.path.join('static', 'uploads', record.filename)
        embed_data(image_path, image_path, new_metadata)  # Overwrite

        extracted_metadata = extract_data(image_path)
        signature = sign_message(private_key_path, extracted_metadata).hex()
        verified = verify_signature(public_key_path, extracted_metadata, bytes.fromhex(signature))

        record.metadata_content = new_metadata
        record.signature = signature
        record.verification = verified
        record.investigator_name = new_investigator
        record.chain_of_custody = new_chain
        record.notes = new_notes

        db.session.commit()

        flash("‚úÖ Metadata updated successfully and re-embedded in the image.", "success")
        return redirect(url_for('view_metadata', record_id=record.id))

    return render_template('edit_metadata.html', record=record)


@app.route('/verify_2fa', methods=['GET', 'POST'])
@login_required
def verify_2fa():
    user = current_user

    # ‚è∞ Check if the code is expired (1 minutes)
    if user.code_sent_at and datetime.utcnow() > user.code_sent_at + timedelta(minutes=1):
        flash("‚è∞ 2FA code expired. Please resend a new code.", "error")
        return render_template("verify_2fa.html", expired=True)

    if request.method == 'POST':
        code = request.form.get('code', '').strip()
        if code == user.two_factor_code:
            session['2fa_verified'] = True  # ‚úÖ Flag session as verified
            flash("‚úÖ 2FA verification successful.", "success")
            return redirect(url_for('home'))
        else:
            flash("‚ùå Incorrect 2FA code.", "error")

    return render_template("verify_2fa.html", expired=False)

@app.route('/resend_2fa_code')
@login_required
def resend_2fa_code():
    user = current_user
    new_code = generate_2fa_code()
    user.two_factor_code = new_code
    user.code_sent_at = datetime.utcnow()
    db.session.commit()
    send_2fa_email(user.email, new_code)
    flash("üìß A new 2FA code has been sent to your email.", "info")
    return redirect(url_for('verify_2fa'))

@app.route('/forensic_images')
def display_images():
    images = ForensicImage.query.all()
    return render_template('forensic_images.html', images=images)

@app.route('/admin/update_user/<int:user_id>', methods=['POST'])
@login_required
@admin_required
def update_user(user_id):
    user = User.query.get_or_404(user_id)
    username = request.form.get('username').strip()
    email = request.form.get('email').strip()
    role = request.form.get('role').strip()
    is_admin = request.form.get('is_admin') == 'on'

    if not username or not email:
        flash("‚ö†Ô∏è Username and Email are required.", "error")
        return redirect(url_for('edit_user', user_id=user_id))

    if User.query.filter((User.username == username, User.id != user_id)).first():
        flash("‚ö†Ô∏è Username already exists.", "error")
        return redirect(url_for('edit_user', user_id=user_id))

    if User.query.filter((User.email == email, User.id != user_id)).first():
        flash("‚ö†Ô∏è Email already exists.", "error")
        return redirect(url_for('edit_user', user_id=user_id))

    user.username = username
    user.email = email
    user.role = role
    user.is_admin = is_admin

    db.session.commit()
    flash("‚úÖ User updated successfully.", "success")
    return redirect(url_for('manage_users'))

@app.route('/admin/users')
@login_required
def manage_users():
    if current_user.role == 'admin':
        flash("Unauthorized access", "error")
        return redirect(url_for('home'))
    users = User.query.filter(User.email != "202120020@uof.ac.ae").all()
    total_users = len(users)
    return render_template('admin_users.html', users=users, total_users=total_users)

@app.route('/admin/promote_legal/<email>')
@login_required
def promote_legal(email):
    if not current_user.is_admin:
        flash("Unauthorized", "error")
        return redirect(url_for('home'))

    user = User.query.filter_by(email=email).first_or_404()
    user.role = 'legal'
    user.is_admin = False
    db.session.commit()
    flash(f"{user.email} promoted to Legal Authority role.", "success")
    return redirect(url_for('dashboard'))

@app.route('/admin/promote/<email>')
@login_required
def promote_user(email):
    if not current_user.is_admin:
        flash("Unauthorized access", "error")
        return redirect(url_for('home'))

    user = User.query.filter_by(email=email).first_or_404()
    user.is_admin = True
    user.role = 'admin'
    db.session.commit()
    flash(f"‚úÖ {user.email} is now an admin.", "success")
    return redirect(url_for('dashboard'))



@app.route('/admin/demote/<email>')
@login_required
def demote_user(email):
    if not current_user.is_admin:
        flash("Unauthorized access", "error")
        return redirect(url_for('home'))
    user = User.query.filter_by(email=email).first_or_404()
    user.is_admin = False
    user.role = 'investigator'
    db.session.commit()
    flash(f"‚úÖ {user.email} is no longer an admin.", "info")
    return redirect(url_for('dashboard'))

@app.route('/legal/dashboard')
@login_required
def legal_dashboard():
    if current_user.role != 'legal':
        flash("Access denied", "error")
        return redirect(url_for('home'))

    query = request.args.get('query', '').lower()

    # Fetch only verified records
    verified_records = ForensicRecord.query.filter_by(verification=True).order_by(ForensicRecord.timestamp.desc()).all()

    # Filter only those that have existing files
    valid_records = []
    for record in verified_records:
        file_path = os.path.join('static', 'uploads', record.filename)
        if os.path.exists(file_path):
            valid_records.append(record)

    # Apply search filter
    if query:
        filtered = [
            r for r in valid_records if (
                query in r.case_id.lower() or
                query in r.investigator_name.lower() or
                query in r.timestamp.strftime('%Y-%m-%d')
            )
        ]
        records = filtered
    else:
        records = valid_records

    return render_template("legal_dashboard.html", records=records)

from flask import make_response
from jinja2 import Template

@app.route('/download_metadata_pdf/<int:record_id>')
@login_required
def download_metadata_pdf(record_id):
    if current_user.role not in ['legal', 'admin']:
        flash("Access denied.", "error")
        return redirect(url_for('home'))

    record = ForensicRecord.query.get_or_404(record_id)

    html = render_template("report_template.html", record=record)

    result = io.BytesIO()
    pisa_status = pisa.CreatePDF(io.StringIO(html), dest=result)

    if pisa_status.err:
        flash("‚ùå Failed to generate PDF.", "error")
        return redirect(url_for('legal_dashboard'))

    response = make_response(result.getvalue())
    response.headers["Content-Type"] = "application/pdf"
    response.headers["Content-Disposition"] = f"attachment; filename={record.case_id}_report.pdf"
    return response

@app.route('/download_metadata/<int:record_id>')
@login_required
def download_metadata(record_id):
    record = ForensicRecord.query.get_or_404(record_id)

    # Prevent legal from accessing unverified records
    if current_user.role == 'legal' and not record.verification:
        flash("‚ùå You are only allowed to download verified reports.", "error")
        return redirect(url_for('legal_dashboard'))

    filename = f"{record.case_id}_report.txt"
    path = os.path.join("static", "reports")
    os.makedirs(path, exist_ok=True)

    full_path = os.path.join(path, filename)
    with open(full_path, "w") as f:
        f.write(f"Case ID: {record.case_id}\n")
        f.write(f"Investigator: {record.investigator_name}\n")
        f.write(f"Timestamp: {record.timestamp}\n")
        f.write(f"\nMetadata:\n{record.metadata_content}\n")
        f.write(f"\nSignature:\n{record.signature}\n")

    return send_from_directory(path, filename, as_attachment=True)

@app.route('/admin/delete/<int:user_id>')
@login_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)
    db.session.delete(user)
    db.session.commit()
    flash("üóëÔ∏è User deleted.", "success")
    return redirect(url_for('manage_users'))

@app.route('/download/<path:filename>')
@login_required
def download_file_invistigator(filename):
    upload_folder = os.path.join(basedir, 'static', 'uploads')
    full_path = os.path.join(upload_folder, filename)
    print("Trying to download:", full_path)
    return send_from_directory(upload_folder, filename, as_attachment=True)

@app.route('/download/<path:filename>')
@login_required
def download_file(filename):
    # Prevent legal from downloading unverified images
    if current_user.role == 'legal':
        record = ForensicRecord.query.filter_by(filename=filename).first()
        if record and not record.verification:
            flash("üö´ You are only allowed to download verified images.", "error")
            return redirect(url_for('legal_dashboard'))

    upload_folder = os.path.join(basedir, 'uploads')
    return send_from_directory(upload_folder, filename, as_attachment=True)

@app.route('/view_metadata/<int:record_id>')
@login_required
def view_metadata(record_id):
    record = ForensicRecord.query.get_or_404(record_id)

    # ‚úÖ Role-based access check
    if current_user.role == 'investigator' and record.user_id != current_user.id:
        flash("üö´ You can only view your own forensic records.", "error")
        return redirect(url_for('investigator_dashboard'))

    if current_user.role not in ['admin', 'legal', 'investigator']:
        flash("üö´ Access denied.", "error")
        return redirect(url_for('home'))

    # ‚úÖ Extract only the "Notes" field
    notes = "N/A"
    for line in record.metadata_content.splitlines():
        if line.lower().startswith("notes:"):
            notes = line.split(":", 1)[1].strip()
            break

    return render_template('view_metadata.html', record=record, notes=notes)

@app.route('/download_metadata/<int:record_id>')
@login_required
def download_update_metadata(record_id):
    record = ForensicRecord.query.get_or_404(record_id)
    filename = f"{record.case_id}_report.txt"
    report_path = os.path.join("static", "reports")
    os.makedirs(report_path, exist_ok=True)

    full_path = os.path.join(report_path, filename)
    with open(full_path, "w") as f:
        f.write(f"Case ID: {record.case_id}\n")
        f.write(f"Investigator: {record.investigator_name}\n")
        f.write(f"Timestamp: {record.timestamp}\n\n")
        f.write(f"Notes:\n{record.notes}\n\n")
        f.write(f"Signature:\n{record.signature}\n")

    return send_from_directory(report_path, filename, as_attachment=True)

@app.route('/investigator/dashboard')
@login_required
def investigator_dashboard():
    if current_user.role != 'investigator':
        flash("Access Denied", "error")
        return redirect(url_for('home'))

    query = request.args.get('query', '').lower()
    all_records = ForensicRecord.query.filter_by(user_id=current_user.id).order_by(ForensicRecord.timestamp.desc()).all()

    # Simple search
    if query:
        records = [
            r for r in all_records if query in str(r.case_id).lower()
                                      or query in str(r.investigator_name).lower()
                                      or query in r.timestamp.strftime('%Y-%m-%d')
        ]
    else:
        records = all_records

    return render_template("investigator_dashboard.html", records=records)
@app.route('/admin/add_user', methods=['GET', 'POST'])
@login_required
@admin_required
def add_user_by_admin():
    if request.method == 'POST':
        username = request.form.get('username', '').strip()
        email = request.form.get('email', '').strip()
        role = request.form.get('role', 'investigator').strip().lower()
        password = request.form.get('password', '').strip()
        confirm_password = request.form.get('confirm_password', '').strip()

        # ‚úÖ Required fields check
        if not username or not email or not password or not confirm_password:
            flash("‚ö†Ô∏è All fields are required.", "error")
            return redirect(url_for('add_user_by_admin'))

        # ‚úÖ Password confirmation
        if password != confirm_password:
            flash("‚ùå Passwords do not match.", "error")
            return redirect(url_for('add_user_by_admin'))

        # ‚úÖ Unique user check
        if User.query.filter((User.username == username) | (User.email == email)).first():
            flash("‚ö†Ô∏è Username or Email already exists.", "error")
            return redirect(url_for('add_user_by_admin'))

        # ‚úÖ Optional: validate role
        if role not in ['admin', 'investigator', 'legal']:
            flash("‚ùå Invalid role selected.", "error")
            return redirect(url_for('add_user_by_admin'))

        # ‚úÖ RSA Key Generation
        from Crypto.PublicKey import RSA
        key = RSA.generate(2048)
        private_key = key.export_key().decode('utf-8')
        public_key = key.publickey().export_key().decode('utf-8')

        # ‚úÖ Password Hashing
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')

        # ‚úÖ Create user
        new_user = User(
            username=username,
            email=email,
            password=hashed_password,
            role=role,
            is_admin=True if role == 'admin' else False,
            is_verified=True,               # Admin-approved users are verified
            private_key=private_key,
            public_key=public_key,
            pending_approval=False          # ‚úÖ Explicitly not pending
        )

        db.session.add(new_user)
        db.session.commit()

        flash(f"‚úÖ User '{username}' added successfully!", "success")
        return redirect(url_for('dashboard'))  # or url_for('manage_users') if you have that route

    return render_template('admin_add_user.html')


@app.route('/verify_again/<int:record_id>', methods=['POST'])
@login_required
def verify_again(record_id):
    record = ForensicRecord.query.get_or_404(record_id)
    image_path = os.path.join('static', 'uploads', record.filename)

    if not os.path.exists(image_path):
        flash("‚ùå Image not found.", "error")
        return redirect(request.referrer or url_for('dashboard'))

    try:
        extracted = extract_data(image_path)

        if extracted == "Missing" or not extracted:
            flash("‚ùå Could not extract metadata for verification.", "error")
            return redirect(request.referrer or url_for('dashboard'))

        is_valid = verify_signature(public_key_path, extracted, bytes.fromhex(record.signature))
        record.verification = is_valid

        if is_valid:
            # ‚úÖ Clear all tamper logs if valid again
            TamperLog.query.filter_by(record_id=record.id).delete()
            flash("‚úÖ Re-verified successfully. Marked as Authentic.", "success")
        else:
            flash("‚ùå Image still Tampered after verification attempt.", "error")

        db.session.commit()

    except Exception as e:
        db.session.rollback()
        flash(f"‚ùå Verification failed: {str(e)}", "error")

    return redirect(request.referrer or url_for('dashboard'))



@app.before_request
def enforce_2fa():
    if not current_user.is_authenticated:
        return

    # Allow access to these routes without 2FA
    allowed = ['verify_2fa', 'resend_2fa_code', 'logout', 'static', 'verify_email']
    if request.endpoint and any(x in request.endpoint for x in allowed):
        return

    # ‚úÖ Block if 2FA not completed
    if current_user.two_factor_code and current_user.code_sent_at:
        if not session.get('2fa_verified'):
            return redirect(url_for('verify_2fa'))


@app.route('/tamper_logs', methods=['GET'])
@login_required
def view_tamper_logs():
    # Fetch logs with related forensic record info (eager loading to avoid lazy errors)
    logs = TamperLog.query.join(ForensicRecord).order_by(TamperLog.timestamp.desc()).all()

    # Optional flash if no logs exist
    if not logs:
        flash("‚úÖ No tampering activity has been logged yet.", "info")

    return render_template('tamper_logs.html', logs=logs)



import re  # üìå Add this at the top if not already imported

@app.route('/upload', methods=['GET', 'POST'])
@login_required
def upload():
    if current_user.role == 'legal':
        flash("üö´ Legal authorities cannot upload images.", "error")
        return redirect(url_for('legal_dashboard'))

    if request.method == 'POST':
        step = request.form.get('step')
        case_id = request.form.get('case_id', '').strip()
        investigator_name = request.form.get('investigator_name')
        timestamp_str = request.form.get('timestamp')
        chain_of_custody = request.form.get('chain_of_custody')
        notes = request.form.get('notes')
        image_filenames = request.form.get('image_filename', '')

        if not re.fullmatch(r'\d{4}', case_id):
            flash("‚ùå Case ID must be exactly 4 digits (e.g., 1234).", "error")
            return redirect(url_for('upload'))

        metadata_string = f"""Case ID: {case_id}
Investigator: {investigator_name}
Timestamp: {timestamp_str}
Chain of Custody: {chain_of_custody}
Notes: {notes}"""

        if step == 'preview':
            uploaded_images = request.files.getlist('images')
            saved_names = []

            for img_file in uploaded_images:
                if img_file and '.' in img_file.filename:
                    import numpy as np
                    file_bytes = np.frombuffer(img_file.read(), np.uint8)
                    img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)

                    temp_path = f'static/uploads/temp_{uuid.uuid4().hex}.png'
                    cv2.imwrite(temp_path, img)

                    try:
                        if "Case ID:" in extract_data(temp_path):
                            flash("üö´ One of the images already contains embedded metadata.", "error")
                            os.remove(temp_path)
                            return redirect(url_for('upload'))
                    except:
                        pass
                    os.remove(temp_path)

                    # Save preview image
                    unique_name = f"{uuid.uuid4().hex}.png"
                    cv2.imwrite(f'static/uploads/{unique_name}', img)
                    saved_names.append(unique_name)

            return render_template("upload.html",
                                   preview_metadata=metadata_string,
                                   image_filename=",".join(saved_names),
                                   case_id=case_id,
                                   investigator_name=investigator_name,
                                   timestamp=timestamp_str,
                                   chain_of_custody=chain_of_custody,
                                   notes=notes,
                                   record=None)

        if step == 'confirm':
            if not image_filenames:
                flash("‚ùå Image not found. Please re-upload and preview.", "error")
                return redirect(url_for('upload'))

            if ForensicRecord.query.filter_by(case_id=case_id).first():
                flash(f"‚ö†Ô∏è Metadata for Case ID {case_id} already exists.", "warning")
                return redirect(url_for('upload'))

            try:
                timestamp = datetime.strptime(timestamp_str, '%Y-%m-%dT%H:%M')
            except:
                flash("‚ö†Ô∏è Invalid timestamp. Using current time.", "warning")
                timestamp = datetime.utcnow()

            if timestamp > datetime.now():
                flash("‚ö†Ô∏è Timestamp cannot be in the future.", "error")
                return redirect(url_for('upload'))

            for filename in image_filenames.split(','):
                input_path = os.path.join('static', 'uploads', filename)
                output_name = f"embedded_{filename}"
                output_path = os.path.join('static', 'uploads', output_name)

                embed_data(input_path, output_path, metadata_string)
                extracted = extract_data(output_path)

                signature = sign_message(private_key_path, extracted).hex()
                verified = verify_signature(public_key_path, extracted, bytes.fromhex(signature))

                record = ForensicRecord(
                    filename=output_name,
                    metadata_content=metadata_string,
                    signature=signature,
                    verification=verified,
                    timestamp=timestamp,
                    user_id=current_user.id,
                    case_id=case_id,
                    investigator_name=investigator_name,
                    chain_of_custody=chain_of_custody,
                    notes=notes
                )
                db.session.add(record)

            db.session.commit()
            flash("‚úÖ All images embedded successfully!", "success")
            return render_template("upload.html",
                                   embedded_image=output_name,
                                   extracted_metadata=extracted,
                                   signature=signature,
                                   verification=verified,
                                   preview_metadata=metadata_string,
                                   image_filename=image_filenames,
                                   case_id=case_id,
                                   investigator_name=investigator_name,
                                   timestamp=timestamp_str,
                                   chain_of_custody=chain_of_custody,
                                   notes=notes,
                                   record=None)

    return render_template("upload.html", record=None)




@app.route('/stored_images', methods=['GET'])
@login_required
def stored_images():
    # Sorting options
    sort_by = request.args.get('sort_by', 'timestamp')
    order = request.args.get('order', 'desc')

    # Sort query
    query = ForensicRecord.query
    if sort_by == 'case_id':
        query = query.order_by(ForensicRecord.case_id.asc() if order == 'asc' else ForensicRecord.case_id.desc())
    else:
        query = query.order_by(ForensicRecord.timestamp.asc() if order == 'asc' else ForensicRecord.timestamp.desc())

    # Pagination
    page = request.args.get('page', 1, type=int)
    per_page = 5
    paginated = query.paginate(page=page, per_page=per_page, error_out=False)

    results = []

    for record in paginated.items:
        image_path = os.path.join('static', 'uploads', record.filename)
        live_status = "Missing"
        live_valid = False
        extracted = "Missing"

        # Check for tamper log existence first
        has_tamper_log = TamperLog.query.filter_by(record_id=record.id).first() is not None

        # üîç Analyze the current file
        if os.path.exists(image_path):
            try:
                extracted = extract_data(image_path)

                if extracted != "Missing":
                    live_valid = verify_signature(public_key_path, extracted, bytes.fromhex(record.signature))
                    live_status = "Authentic" if live_valid else "Tampered"
                else:
                    live_status = "Missing Metadata"

            except Exception as e:
                live_status = f"Verification Failed: {str(e)}"
                extracted = "Error"

        else:
            live_status = "Missing File"

        # üö® Force status to "Tampered" if tamper log exists
        stored_status = "Tampered" if has_tamper_log else ("Authentic" if record.verification else "Tampered")
        if has_tamper_log:
            live_status = "Tampered"
            live_valid = False

        results.append({
            'record': record,
            'stored_status': stored_status,
            'live_status': live_status,
            'live_valid': live_valid,
            'extracted': extracted
        })

    return render_template('stored_images.html',
                           results=results,
                           pagination=paginated,
                           sort_by=sort_by,
                           order=order)

@app.route('/extract', methods=['GET', 'POST'], endpoint='extract')
@login_required
def extract():
    if current_user.role == 'legal':
        flash("üö´ Legal authorities cannot extract metadata manually.", "error")
        return redirect(url_for('legal_dashboard'))

    if request.method == 'POST':
        image = request.files.get('image')
        case_id = request.form.get('case_id', '').strip()

        if not image:
            flash("‚ùå Please upload an image.", "error")
            return redirect(url_for('extract'))

        if not is_allowed_file(image.filename):
            flash("‚ùå Invalid image format.", "error")
            return redirect(url_for('extract'))

        ext = os.path.splitext(secure_filename(image.filename))[1]
        filename = f"{uuid.uuid4().hex}{ext}"
        input_path = os.path.join('uploads', filename)
        os.makedirs('uploads', exist_ok=True)
        image.save(input_path)

        try:
            extracted_metadata = extract_data(input_path)
            embedded_case_id = next(
                (line.split(":", 1)[1].strip() for line in extracted_metadata.splitlines() if line.lower().startswith("case id:")),
                None
            )

            if not embedded_case_id:
                flash("‚ö†Ô∏è Could not extract Case ID from metadata.", "error")
                return render_template("extract.html", extracted_metadata=extracted_metadata, verification=False,
                                       signature=None, filename=filename, case_id=case_id)

            # Auto-fill if the user left case ID blank
            if not case_id:
                case_id = embedded_case_id

            if embedded_case_id != case_id:
                flash(f"‚ùå Case ID mismatch. The embedded ID is '{embedded_case_id}', but you entered '{case_id}'.", "error")
                return render_template("extract.html", extracted_metadata=extracted_metadata, verification=False,
                                       signature=None, filename=filename, case_id=case_id)

            record = ForensicRecord.query.filter_by(case_id=case_id).first()
            if not record:
                flash("‚ùå No forensic record found for this Case ID.", "error")
                return render_template("extract.html", extracted_metadata=extracted_metadata, verification=False,
                                       signature=None, filename=filename, case_id=case_id)

            # Restrict investigators from extracting others' records
            if current_user.role == 'investigator' and record.user_id != current_user.id:
                flash("üö´ You are only allowed to extract your own forensic records.", "error")
                return redirect(url_for('extract'))

            # ‚úÖ Hash Check
            uploaded_hash = hashlib.sha256(open(input_path, 'rb').read()).hexdigest()
            original_path = os.path.join('static', 'uploads', record.filename)

            if os.path.exists(original_path):
                original_hash = hashlib.sha256(open(original_path, 'rb').read()).hexdigest()
                if uploaded_hash != original_hash:
                    if not TamperLog.query.filter_by(record_id=record.id, discrepancy_details="‚ö†Ô∏è Image file hash mismatch: content has been altered.").first():
                        tamper = TamperLog(
                            record_id=record.id,
                            discrepancy_details="‚ö†Ô∏è Image file hash mismatch: content has been altered.",
                            notified=False
                        )
                        db.session.add(tamper)

                    record.verification = False
                    db.session.commit()
                    send_authority_alert(record)
                    flash("üö® Image file has been tampered. Tampering logged.", "error")
                    return redirect(url_for('view_tamper_logs'))
            else:
                flash("‚ö†Ô∏è Original file missing. Cannot verify hash.", "warning")

            # ‚úÖ Signature Verification
            is_verified = verify_signature(public_key_path, extracted_metadata, bytes.fromhex(record.signature))

            if is_verified:
                record.verification = True
                db.session.commit()
                flash("‚úÖ Metadata extracted and verified successfully.", "success")
            else:
                if not TamperLog.query.filter_by(record_id=record.id, discrepancy_details="‚ö†Ô∏è Digital signature mismatch detected.").first():
                    tamper = TamperLog(
                        record_id=record.id,
                        discrepancy_details="‚ö†Ô∏è Digital signature mismatch detected.",
                        notified=False
                    )
                    db.session.add(tamper)

                record.verification = False
                db.session.commit()
                send_authority_alert(record)
                flash("üö® Metadata has been modified. Tampering logged.", "error")
                return redirect(url_for('view_tamper_logs'))

            return render_template("extract.html",
                                   extracted_metadata=extracted_metadata,
                                   verification=is_verified,
                                   signature=record.signature,
                                   filename=filename,
                                   case_id=case_id)

        except Exception as e:
            flash(f"‚ùå Extraction error: {str(e)}", "error")
            if record:
                if not TamperLog.query.filter_by(record_id=record.id, discrepancy_details=str(e)).first():
                    try:
                        tamper = TamperLog(
                            record_id=record.id,
                            discrepancy_details=f"‚ùå Metadata extraction failed: {str(e)}",
                            notified=False
                        )
                        db.session.add(tamper)
                        db.session.commit()
                        send_authority_alert(record)
                        return redirect(url_for('view_tamper_logs'))
                    except Exception as inner_err:
                        db.session.rollback()
                        flash(f"‚ùå Tamper log save failed: {inner_err}", "error")

        finally:
            if os.path.exists(input_path):
                os.remove(input_path)

    return render_template("extract.html", case_id='')




from validate_email_address import validate_email
import re

from itsdangerous import URLSafeTimedSerializer

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username', '').strip()
        email = request.form.get('email', '').strip()
        password = request.form.get('password', '').strip()
        confirm_password = request.form.get('confirm_password', '').strip()
        role = request.form.get('role', 'investigator').strip().lower()

        # ‚úÖ Required fields
        if not username or not email or not password or not confirm_password or not role:
            flash("‚ö†Ô∏è All fields are required.", "error")
            return render_template('register.html')

        # ‚úÖ Basic email format check
        if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):
            flash("‚ùå Invalid email format.", "error")
            return render_template('register.html')

        # ‚úÖ DNS-level email structure validation (optional only)
        if not validate_email(email):
            flash("‚ùå Please enter a valid and reachable email address.", "error")
            return render_template('register.html')

        # ‚úÖ Password match & strength check
        if password != confirm_password:
            flash("‚ùå Passwords do not match.", "error")
            return render_template('register.html')

        if len(password) < 8 or not any(c.isdigit() for c in password) or \
           not any(c.isupper() for c in password) or not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):
            flash("‚ùå Password must include uppercase, number, and special character.", "error")
            return render_template('register.html')

        # ‚úÖ Check uniqueness
        if User.query.filter((User.username == username) | (User.email == email)).first():
            flash("‚ö†Ô∏è Username or Email already exists.", "error")
            return render_template('register.html')

        # ‚úÖ Generate RSA Keys
        user_key = RSA.generate(2048)
        private_key = user_key.export_key().decode('utf-8')
        public_key = user_key.publickey().export_key().decode('utf-8')

        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')
        verification_code = generate_verification_code()
        is_admin_flag = True if role == 'admin' else False

        new_user = User(
            username=username,
            email=email,
            password=hashed_password,
            role=role,
            is_admin=is_admin_flag,
            verification_code=verification_code,
            is_verified=False,
            private_key=private_key,
            public_key=public_key,
            pending_approval=True
        )

        db.session.add(new_user)
        db.session.commit()

        # ‚úÖ Generate tokens
        s = URLSafeTimedSerializer(app.config['SECRET_KEY'])
        approve_token = s.dumps(email + '|approve')
        reject_token = s.dumps(email + '|reject')

        approve_url = url_for('approve_user', token=approve_token, _external=True)
        reject_url = url_for('reject_user', token=reject_token, _external=True)

        # ‚úÖ Email HTML
        msg = Message("üë§ New User Approval Needed",
                      sender=app.config['MAIL_USERNAME'],
                      recipients=[admin.email for admin in User.query.filter_by(is_admin=True).all()])

        msg.html = f"""
        <div style="font-family: Arial, sans-serif; background-color: #f9f9f9; padding: 25px; border-radius: 10px; color: #333;">
          <h2 style="margin-top: 0; color: #333;">üë§ New User Registration Request</h2>
          <p style="font-size: 15px;">A new user has registered and is waiting for your approval:</p>

          <ul style="font-size: 15px; line-height: 1.6; padding-left: 20px;">
            <li><strong>Username:</strong> {username}</li>
            <li><strong>Email:</strong> <a href="mailto:{email}" style="color: #0066cc;">{email}</a></li>
            <li><strong>Role:</strong> {role.capitalize()}</li>
          </ul>

          <div style="margin-top: 30px;">
            <a href="{approve_url}" 
               style="background-color: #28a745; color: white; text-decoration: none; 
                      padding: 12px 22px; border-radius: 6px; font-size: 15px; font-weight: bold; display: inline-block;">
              ‚úÖ Approve
            </a>
            &nbsp;&nbsp;
            <a href="{reject_url}" 
               style="background-color: #dc3545; color: white; text-decoration: none; 
                      padding: 12px 22px; border-radius: 6px; font-size: 15px; font-weight: bold; display: inline-block;">
              ‚ùå Reject
            </a>
          </div>
        </div>
        """

        mail.send(msg)

        flash("‚úÖ Registration submitted. Awaiting admin approval.", "info")
        return redirect(url_for('login'))

    return render_template('register.html')

@app.route('/check_email', methods=['POST'])
def check_email():
    data = request.get_json()
    email = data.get('email', '').strip()

    # Check format first
    if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):
        return jsonify({'status': 'invalid_format'})

    # Check if the email domain is real
    if not validate_email(email, verify=True):
        return jsonify({'status': 'unreachable'})

    # Check if email is already in use
    if User.query.filter_by(email=email).first():
        return jsonify({'status': 'taken'})

    return jsonify({'status': 'available'})




@app.route('/delete_record/<int:record_id>', methods=['POST'])
@login_required
def delete_record(record_id):
    if current_user.role == 'legal':
        flash("üö´ Legal authorities cannot delete records.", "error")
        return redirect(url_for('legal_dashboard'))

    record = ForensicRecord.query.get_or_404(record_id)

    # üõ°Ô∏è Safely delete associated tamper logs first
    TamperLog.query.filter_by(record_id=record.id).delete()

    db.session.delete(record)
    db.session.commit()

    flash('‚úÖ Record and associated tamper logs deleted successfully.', 'success')
    return redirect(url_for('dashboard'))


@app.route('/verify', methods=['GET', 'POST'])
def verify_email():
    email = session.get('email')
    if not email:
        flash("Session expired. Please log in again.", "error")
        return redirect(url_for('login'))

    user = User.query.filter_by(email=email).first()
    if not user:
        flash("User not found.", "error")
        return redirect(url_for('login'))

    if request.method == 'POST':
        code = request.form.get('code').strip()
        if user.verification_code == code:
            user.is_verified = True
            user.verification_code = ""
            db.session.commit()
            flash("‚úÖ Email verified successfully. You can now log in.", "success")
            return redirect(url_for('login'))
        else:
            flash("‚ùå Incorrect verification code.", "error")

    return render_template('verify.html', email=email)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        identifier = request.form.get('identifier', '').strip()
        password = request.form.get('password')
        selected_role = request.form.get('role')

        user = User.query.filter((User.username == identifier) | (User.email == identifier)).first()

        if user and check_password_hash(user.password, password):
            if not user.is_verified:
                flash("‚ö†Ô∏è Please verify your email first.", "warning")
                session['email'] = user.email
                return redirect(url_for('verify_email'))
            if user.pending_approval:
                flash("‚è≥ Your account is awaiting admin approval.", "warning")
                return redirect(url_for('login'))

            if selected_role != user.role:
                flash("‚ùå Role mismatch. Please check your selected role.", "error")
                return redirect(url_for('login'))

            login_user(user)
            session['server_id'] = SERVER_SESSION_ID
            flash(f"üëã Welcome back, {user.username}!", "success")
            return redirect(url_for('home'))

        flash("‚ùå Invalid credentials or role mismatch.", "error")

    return render_template('login.html')


@app.route('/logout')
@login_required
def logout():
    logout_user()
    session.pop('2fa_verified', None)  # ‚úÖ Clear 2FA session
    return redirect(url_for('root_home'))

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    port = int(os.environ.get('PORT', 10000))  # Render provides PORT dynamically

    app.run(host='0.0.0.0', port=port)


